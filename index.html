<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>3×3 Sliding Tile Puzzle (retro)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* Late-1990s / early web look: plain, square edges, visible borders, system font */
  html,body {
    height:100%;
    margin:0;
    padding:10px;
    background:#f0f0f0;
    color:#000;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size:14px;
  }
  h1 {
    font-size:18px;
    margin:0 0 10px 0;
  }
  .layout {
    display:flex;
    gap:16px;
    align-items:flex-start;
  }

  /* Puzzle area */
  .puzzle-wrap {
    border:2px solid #000;
    padding:8px;
    background:#fff;
    width:236px; /* grid + padding */
  }
  #puzzle {
    width:210px;
    height:210px;
    display:grid;
    grid-template-columns:repeat(3, 1fr);
    grid-template-rows:repeat(3, 1fr);
    gap:6px;
    box-sizing:border-box;
  }
  .tile {
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:28px;
    border:2px solid #000;
    background:#eaeaea;
    cursor:pointer;
    user-select:none;
    -webkit-user-select:none;
    outline: none;
  }
  .tile.blank {
    background:#fff;
    cursor:default;
  }
  .tile:focus {
    outline:2px dotted #000;
  }

  /* Controls and stats */
  .controls {
    display:flex;
    flex-direction:column;
    gap:8px;
    width:300px;
  }
  .buttons {
    display:flex;
    gap:8px;
    margin-bottom:6px;
  }
  button {
    padding:6px 10px;
    border:2px solid #000;
    background:#ddd;
    cursor:pointer;
    box-sizing:border-box;
    /* no rounded corners, no shadows */
    border-radius:0;
  }
  button:active { transform: translateY(0px); }
  .small {
    padding:4px 6px;
  }

  .stats {
    border:1px solid #000;
    padding:8px;
    background:#fff;
  }
  .stat-row {
    margin:4px 0;
  }

  /* High scores */
  .scores {
    margin-top:6px;
    border:1px solid #000;
    padding:8px;
    background:#fff;
  }
  .scores ol {
    margin:6px 0 0 18px;
    padding:0;
  }

  /* Solved flash: quick, simple */
  @keyframes retroFlash {
    0% { background-color: #fff; }
    25% { background-color: #ffff66; }
    50% { background-color: #fff; }
    75% { background-color: #ffff66; }
    100% { background-color: #fff; }
  }
  .flash {
    animation: retroFlash 0.8s linear;
  }

  /* small footer text */
  .note { font-size:12px; color:#333; margin-top:8px; }
</style>
</head>
<body>
  <h1>3×3 Sliding Tile Puzzle</h1>
  <div class="layout">
    <div class="puzzle-wrap" id="puzzleWrap">
      <div id="puzzle" aria-label="Sliding puzzle" role="application" tabindex="0"></div>
    </div>

    <div class="controls">
      <div class="buttons">
        <button id="shuffleBtn">Shuffle</button>
        <button id="resetBtn">Reset</button>
      </div>

      <div class="stats">
        <div class="stat-row"><strong>Moves:</strong> <span id="moves">0</span></div>
        <div class="stat-row"><strong>Time:</strong> <span id="time">00:00</span></div>
        <div class="stat-row"><strong>Status:</strong> <span id="status">Not solved</span></div>
      </div>

      <div class="scores">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>High Scores (Top 5)</strong>
          <button id="clearScoresBtn" class="small">Clear Scores</button>
        </div>
        <ol id="highScoresList"></ol>
      </div>

      <div class="note">
        Controls: Click tiles to move or use arrow keys to slide tile(s) into the blank. Two-space slides are allowed when blank is two tiles away in the same row/column.
      </div>
    </div>
  </div>

<script>
(function() {
  // Board indices: 0..8, row = Math.floor(i/3), col = i%3
  // Solved board: 1..8, 0 blank at index 8
  const PUZZLE_SIZE = 3;
  const SOLVED = [1,2,3,4,5,6,7,8,0];

  let board = SOLVED.slice();
  const puzzleEl = document.getElementById('puzzle');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');
  const statusEl = document.getElementById('status');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const highScoresList = document.getElementById('highScoresList');
  const clearScoresBtn = document.getElementById('clearScoresBtn');
  const puzzleWrap = document.getElementById('puzzleWrap');

  let moves = 0;
  let timerInterval = null;
  let startTime = null;
  let elapsedSeconds = 0;
  let started = false;

  // LocalStorage key
  const LS_KEY = 'slidingHighScores3x3';

  function render() {
    // Clear puzzle
    puzzleEl.innerHTML = '';
    for (let i = 0; i < 9; i++) {
      const tile = document.createElement('div');
      tile.className = 'tile' + (board[i] === 0 ? ' blank' : '');
      tile.setAttribute('data-index', i);
      tile.setAttribute('tabindex', board[i] === 0 ? '-1' : '0');
      tile.setAttribute('role', board[i] === 0 ? 'img' : 'button');
      tile.setAttribute('aria-label', board[i] === 0 ? 'blank' : 'tile ' + board[i]);
      tile.textContent = board[i] === 0 ? '' : board[i];
      tile.addEventListener('click', onTileClick);
      tile.addEventListener('keydown', function(e){
        // allow Enter/Space on tiles to activate
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onTileClick.call(this, e);
        }
      });
      puzzleEl.appendChild(tile);
    }
    movesEl.textContent = moves;
    timeEl.textContent = formatTime(elapsedSeconds);
    statusEl.textContent = isSolved() ? 'Solved' : 'Not solved';
  }

  // Helper: format seconds to mm:ss
  function formatTime(s) {
    const mm = Math.floor(s/60).toString().padStart(2,'0');
    const ss = Math.floor(s%60).toString().padStart(2,'0');
    return mm + ':' + ss;
  }

  function getBlankIndex() {
    return board.indexOf(0);
  }

  function indexToRC(idx) {
    return { r: Math.floor(idx/PUZZLE_SIZE), c: idx % PUZZLE_SIZE };
  }

  function canMove(tileIndex) {
    const b = getBlankIndex();
    if (tileIndex === b) return false;
    const t = indexToRC(tileIndex);
    const bl = indexToRC(b);
    if (t.r === bl.r) {
      const dc = Math.abs(t.c - bl.c);
      return dc === 1 || dc === 2;
    }
    if (t.c === bl.c) {
      const dr = Math.abs(t.r - bl.r);
      return dr === 1 || dr === 2;
    }
    return false;
  }

  // Shift tiles between blank and tileIndex so blank ends up at tileIndex.
  function shiftTilesToBlank(tileIndex) {
    const b = getBlankIndex();
    if (!canMove(tileIndex)) return false;
    // Determine step: +1/-1 for row moves, +3/-3 for col moves
    let step = 0;
    if (Math.floor(tileIndex/PUZZLE_SIZE) === Math.floor(b/PUZZLE_SIZE)) {
      // same row
      step = (b < tileIndex) ? +1 : -1;
    } else {
      // same column
      step = (b < tileIndex) ? +PUZZLE_SIZE : -PUZZLE_SIZE;
    }

    if (step > 0) {
      // iterate idx from b to tileIndex- step wise
      for (let idx = b; idx !== tileIndex; idx += step) {
        board[idx] = board[idx + step];
      }
      board[tileIndex] = 0;
    } else {
      // step < 0, iterate downwards
      for (let idx = b; idx !== tileIndex; idx += step) {
        board[idx] = board[idx + step];
      }
      board[tileIndex] = 0;
    }
    return true;
  }

  function onTileClick(e) {
    const idx = Number(this.getAttribute('data-index'));
    if (moveTile(idx)) {
      // focus puzzle to capture keyboard navigation if needed
      puzzleEl.focus();
    }
  }

  function moveTile(tileIndex) {
    if (!canMove(tileIndex)) return false;
    // start timer on first move
    if (!started) startTimer();
    // perform shift
    const moved = shiftTilesToBlank(tileIndex);
    if (!moved) return false;
    moves++;
    render();
    if (isSolved()) {
      stopTimer();
      statusEl.textContent = 'Solved';
      flashPuzzle();
      maybeAddHighScore();
    }
    return true;
  }

  // Keyboard handler: arrow keys move tile(s) into blank from that direction
  function onKeyDown(e) {
    const key = e.key;
    const b = getBlankIndex();
    let target = null;
    if (key === 'ArrowLeft') {
      // want tile to left of blank (blankIndex -1 or -2)
      const col = b % PUZZLE_SIZE;
      if (col >= 1) {
        target = b - 1;
      } else if (col >= 2) {
        target = b - 2;
      }
    } else if (key === 'ArrowRight') {
      const col = b % PUZZLE_SIZE;
      if (col <= PUZZLE_SIZE - 2) {
        target = b + 1;
      } else if (col <= PUZZLE_SIZE - 3) {
        target = b + 2;
      }
    } else if (key === 'ArrowUp') {
      const row = Math.floor(b / PUZZLE_SIZE);
      if (row >= 1) {
        target = b - PUZZLE_SIZE;
      } else if (row >= 2) {
        target = b - 2*PUZZLE_SIZE;
      }
    } else if (key === 'ArrowDown') {
      const row = Math.floor(b / PUZZLE_SIZE);
      if (row <= PUZZLE_SIZE - 2) {
        target = b + PUZZLE_SIZE;
      } else if (row <= PUZZLE_SIZE - 3) {
        target = b + 2*PUZZLE_SIZE;
      }
    } else {
      return; // ignore other keys
    }
    // Special handling: if the immediate adjacent exists, prefer it; else check two-away if same row/col
    // The above logic sets target to adjacent if available, else (if impossible) tries two-away, but ensure validity:
    if (target !== null && canMove(target)) {
      e.preventDefault();
      moveTile(target);
    } else {
      // Try two-away explicitly: check two-away positions and move if allowed
      let maybe = null;
      if (key === 'ArrowLeft') {
        const col = b % PUZZLE_SIZE;
        if (col >= 2) maybe = b - 2;
      } else if (key === 'ArrowRight') {
        const col = b % PUZZLE_SIZE;
        if (col <= PUZZLE_SIZE - 3) maybe = b + 2;
      } else if (key === 'ArrowUp') {
        const row = Math.floor(b/PUZZLE_SIZE);
        if (row >= 2) maybe = b - 2*PUZZLE_SIZE;
      } else if (key === 'ArrowDown') {
        const row = Math.floor(b/PUZZLE_SIZE);
        if (row <= PUZZLE_SIZE - 3) maybe = b + 2*PUZZLE_SIZE;
      }
      if (maybe !== null && canMove(maybe)) {
        e.preventDefault();
        moveTile(maybe);
      }
    }
  }

  // Timer functions
  function startTimer() {
    if (timerInterval) return;
    started = true;
    startTime = Date.now() - elapsedSeconds*1000;
    timerInterval = setInterval(function() {
      elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      timeEl.textContent = formatTime(elapsedSeconds);
    }, 250);
  }
  function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
    started = false;
  }
  function resetTimer() {
    stopTimer();
    elapsedSeconds = 0;
    timeEl.textContent = formatTime(elapsedSeconds);
  }

  // Shuffle: generate random solvable permutation
  function shuffleBoard() {
    // generate random permutation until solvable and not solved
    let arr;
    do {
      arr = shuffleArray([1,2,3,4,5,6,7,8,0]);
    } while (!isSolvable(arr) || arraysEqual(arr, SOLVED));
    board = arr;
    moves = 0;
    resetTimer();
    render();
  }

  function resetBoard() {
    board = SOLVED.slice();
    moves = 0;
    resetTimer();
    render();
  }

  // Utility: Fisher-Yates shuffle
  function shuffleArray(a) {
    const arr = a.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  // Solvability for 3x3: inversion count even -> solvable
  function isSolvable(arr) {
    const flat = arr.filter(x=>x!==0);
    let inv = 0;
    for (let i = 0; i < flat.length; i++) {
      for (let j = i+1; j < flat.length; j++) {
        if (flat[i] > flat[j]) inv++;
      }
    }
    return inv % 2 === 0;
  }

  function arraysEqual(a,b) {
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
    return true;
  }

  function isSolved() {
    return arraysEqual(board, SOLVED);
  }

  // Flash puzzle area briefly when solved
  function flashPuzzle() {
    puzzleWrap.classList.add('flash');
    setTimeout(()=>puzzleWrap.classList.remove('flash'), 900);
  }

  // High Scores management
  function loadHighScores() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed;
    } catch (err) {
      return [];
    }
  }
  function saveHighScores(list) {
    localStorage.setItem(LS_KEY, JSON.stringify(list));
  }
  function updateHighScoresListUI() {
    const scores = loadHighScores();
    highScoresList.innerHTML = '';
    if (scores.length === 0) {
      highScoresList.innerHTML = '<li><em>No scores yet</em></li>';
      return;
    }
    for (const s of scores) {
      const li = document.createElement('li');
      li.textContent = `${formatTime(s.time)} — ${s.moves} moves`;
      highScoresList.appendChild(li);
    }
  }

  function maybeAddHighScore() {
    // On solve, add {moves, time} to high scores if qualifies; keep top 5
    const elapsed = elapsedSeconds;
    const entry = { moves: moves, time: elapsed, created: Date.now() };
    let scores = loadHighScores();
    // add then sort by time asc then moves asc
    scores.push(entry);
    scores.sort((a,b) => {
      if (a.time !== b.time) return a.time - b.time;
      if (a.moves !== b.moves) return a.moves - b.moves;
      return a.created - b.created;
    });
    // trim to 5
    if (scores.length > 5) scores = scores.slice(0,5);
    saveHighScores(scores);
    updateHighScoresListUI();
  }

  // Clear scores
  clearScoresBtn.addEventListener('click', function() {
    if (confirm('Clear high scores?')) {
      localStorage.removeItem(LS_KEY);
      updateHighScoresListUI();
    }
  });

  // Setup event handlers
  shuffleBtn.addEventListener('click', function() {
    shuffleBoard();
    puzzleEl.focus();
  });
  resetBtn.addEventListener('click', function() {
    resetBoard();
    puzzleEl.focus();
  });

  document.addEventListener('keydown', onKeyDown);

  // Initialize
  resetBoard();
  updateHighScoresListUI();

  // Expose some functions for debugging (not necessary)
  window._slidingPuzzle = {
    board: () => board.slice(),
    shuffle: shuffleBoard,
    reset: resetBoard,
    highScores: loadHighScores
  };

})();
</script>
</body>
</html>
