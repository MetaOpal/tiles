<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>3×3 Sliding Tile Puzzle</title>
<style>
  /* Late 1990s look: plain, system fonts, visible borders, square buttons, no rounded corners */
  html,body { height:100%; margin:0; padding:20px; background:#f0f0f0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; color:#000; }
  h1 { font-size:18px; margin:0 0 12px 0; }
  #container { width:280px; }
  #board { width:270px; height:270px; border:2px solid #000; display:grid; grid-template: repeat(3, 1fr) / repeat(3, 1fr); background:#fff; }
  .tile {
    box-sizing:border-box;
    border:1px solid #000;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:bold;
    font-size:36px;
    cursor:pointer;
    user-select:none;
    outline: none;
    background: #eaeaea;
  }
  .tile.blank { background:#fff; cursor:default; }
  .controls { margin-top:12px; display:flex; gap:8px; }
  button {
    padding:6px 10px;
    border:2px solid #000;
    background:#ddd;
    cursor:pointer;
    font-size:13px;
  }
  button:active { background:#ccc; }
  .info { margin-top:10px; font-size:13px; }
  .status { margin-top:6px; font-weight:bold; }
  .flash {
    animation: flash-bg 600ms linear 0s 3;
  }
  @keyframes flash-bg {
    0% { background-color: #fff; }
    25% { background-color: #ff0; }
    50% { background-color: #fff; }
    75% { background-color: #ff0; }
    100% { background-color: #fff; }
  }

  /* High scores */
  #scores { margin-top:14px; font-size:13px; border-top:1px solid #000; padding-top:10px; }
  #scores ol { padding-left:18px; margin:4px 0 8px 0; }
  #scores small { display:block; color:#333; margin-top:6px; }
  /* Minimal accessibility focus */
  .tile:focus { outline:2px dotted #000; }
</style>
</head>
<body>
<div id="container">
  <h1>3×3 Sliding Tile Puzzle</h1>
  <div id="board" aria-label="Sliding puzzle board" tabindex="0"></div>

  <div class="controls">
    <button id="shuffleBtn" type="button">Shuffle</button>
    <button id="resetBtn" type="button">Reset</button>
    <button id="clearScoresBtn" type="button">Clear Scores</button>
  </div>

  <div class="info">
    <div>Moves: <span id="moves">0</span></div>
    <div>Time: <span id="time">0:00</span></div>
    <div class="status" id="status">Not solved</div>
  </div>

  <div id="scores">
    <strong>High Scores (top 5)</strong>
    <ol id="scoreList"></ol>
    <small>(Sorted by moves, then time. Stored locally in your browser.)</small>
  </div>
</div>

<script>
(function(){
  // Board representation: array of 9 numbers: 1..8, 0 = blank
  const boardEl = document.getElementById('board');
  const movesEl = document.getElementById('moves');
  const timeEl = document.getElementById('time');
  const statusEl = document.getElementById('status');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const clearScoresBtn = document.getElementById('clearScoresBtn');
  const scoreListEl = document.getElementById('scoreList');

  const STORAGE_KEY = 'sliding_highscores_v1';

  let board = [];
  let moves = 0;
  let timer = null;
  let startTime = null;
  let elapsedSeconds = 0;
  let isShuffling = false;
  let solved = false;

  function solvedLayout() { return [1,2,3,4,5,6,7,8,0]; }

  // Render board
  function render() {
    boardEl.innerHTML = '';
    board.forEach((v, idx) => {
      const tile = document.createElement('div');
      tile.className = 'tile' + (v===0 ? ' blank' : '');
      tile.setAttribute('data-index', idx);
      tile.setAttribute('tabindex', v===0 ? '-1' : '0');
      tile.textContent = v===0 ? '' : v;
      tile.addEventListener('click', onTileClick);
      tile.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { onTileClick(e); e.preventDefault(); }
      });
      boardEl.appendChild(tile);
    });
  }

  // Helpers: index -> row/col
  function rowOf(i){ return Math.floor(i/3); }
  function colOf(i){ return i%3; }
  function indexOf(r,c){ return r*3 + c; }

  // Find index of value
  function idxOf(val){ return board.indexOf(val); }

  // Check adjacency or two-away in same row/col
  function canMoveFrom(sourceIdx, blankIdx) {
    const sr = rowOf(sourceIdx), sc = colOf(sourceIdx);
    const br = rowOf(blankIdx), bc = colOf(blankIdx);
    // same row
    if (sr === br) {
      const d = Math.abs(sc - bc);
      return d === 1 || d === 2;
    }
    // same col
    if (sc === bc) {
      const d = Math.abs(sr - br);
      return d === 1 || d === 2;
    }
    return false;
  }

  // Move logic: if source and blank adjacent -> swap; if two away -> shift both tiles toward blank
  function moveFrom(sourceIdx) {
    if (isShuffling || solved) return false;
    const blankIdx = idxOf(0);
    if (!canMoveFrom(sourceIdx, blankIdx)) return false;
    performMove(sourceIdx, blankIdx);
    return true;
  }

  function performMove(sourceIdx, blankIdx) {
    const sr = rowOf(sourceIdx), sc = colOf(sourceIdx);
    const br = rowOf(blankIdx), bc = colOf(blankIdx);

    // Single adjacent swap
    if (Math.abs(sr-br) + Math.abs(sc-bc) === 1) {
      // swap
      [board[sourceIdx], board[blankIdx]] = [board[blankIdx], board[sourceIdx]];
    } else {
      // two-away same row or column: shift tiles between source and blank toward blank
      if (sr === br && Math.abs(sc-bc) === 2) {
        // same row horizontal shift
        const midC = (sc + bc) / 2;
        const midIdx = indexOf(sr, midC);
        // Move mid tile into blank, source tile into mid, blank goes to source
        board[blankIdx] = board[midIdx];
        board[midIdx] = board[sourceIdx];
        board[sourceIdx] = 0;
      } else if (sc === bc && Math.abs(sr-br) === 2) {
        // same column vertical shift
        const midR = (sr + br) / 2;
        const midIdx = indexOf(midR, sc);
        board[blankIdx] = board[midIdx];
        board[midIdx] = board[sourceIdx];
        board[sourceIdx] = 0;
      } else {
        // shouldn't happen
        return;
      }
    }

    // Start timer on first move (if not already running)
    if (!timer) startTimer();

    moves++;
    updateHUD();
    render();
    checkSolved();
  }

  function onTileClick(e) {
    const idx = Number(e.currentTarget.getAttribute('data-index'));
    if (board[idx] === 0) return;
    moveFrom(idx);
  }

  // Arrow keys: pressing arrow slides tile in that direction into the blank (if present)
  function onKeyDown(e) {
    if (isShuffling) return;
    const blankIdx = idxOf(0);
    const br = rowOf(blankIdx), bc = colOf(blankIdx);
    let sourceR = br, sourceC = bc;

    // ArrowUp => move tile below blank up into blank (so sourceRow = br+1)
    if (e.key === 'ArrowUp') sourceR = br + 1;
    else if (e.key === 'ArrowDown') sourceR = br - 1;
    else if (e.key === 'ArrowLeft') sourceC = bc + 1;
    else if (e.key === 'ArrowRight') sourceC = bc - 1;
    else return;

    // out of bounds? handle two-away as well: if immediately out of bounds try two-away
    if (sourceR < 0 || sourceR > 2 || sourceC < 0 || sourceC > 2) {
      // try two-away
      if (e.key === 'ArrowUp') sourceR = br + 2;
      else if (e.key === 'ArrowDown') sourceR = br - 2;
      else if (e.key === 'ArrowLeft') sourceC = bc + 2;
      else if (e.key === 'ArrowRight') sourceC = bc - 2;
      // still out => ignore
    }

    if (sourceR < 0 || sourceR > 2 || sourceC < 0 || sourceC > 2) return;
    const sourceIdx = indexOf(sourceR, sourceC);
    if (canMoveFrom(sourceIdx, blankIdx)) {
      moveFrom(sourceIdx);
      e.preventDefault();
    }
  }

  // Timer functions
  function startTimer() {
    if (timer) return;
    startTime = Date.now() - elapsedSeconds * 1000;
    timer = setInterval(() => {
      elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      updateTime();
    }, 250);
  }
  function stopTimer() {
    if (timer) {
      clearInterval(timer); timer = null;
    }
  }
  function resetTimer() {
    stopTimer();
    elapsedSeconds = 0;
    updateTime();
  }
  function updateTime() {
    const s = elapsedSeconds % 60;
    const m = Math.floor(elapsedSeconds / 60);
    timeEl.textContent = m + ':' + (s < 10 ? '0' + s : s);
  }

  function updateHUD() {
    movesEl.textContent = moves;
  }

  // Shuffle by doing a sequence of random legal moves from solved state (ensures solvable)
  function shuffle(times = 200) {
    isShuffling = true;
    board = solvedLayout().slice();
    let lastMove = -1;
    for (let i=0;i<times;i++) {
      const blank = idxOf(0);
      const neighbors = getLegalSources(blank).filter(n => n !== lastMove);
      const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
      // perform single or two-tile move randomly if possible
      const cand = pick;
      // do move (simulate)
      const br = rowOf(blank), bc = colOf(blank);
      const sr = rowOf(cand), sc = colOf(cand);
      if (Math.abs(sr-br)+Math.abs(sc-bc) === 1) {
        [board[cand], board[blank]] = [board[blank], board[cand]];
      } else {
        // two-away shift
        if (sr === br && Math.abs(sc-bc) === 2) {
          const mid = indexOf(sr, (sc+bc)/2);
          board[blank] = board[mid];
          board[mid] = board[cand];
          board[cand] = 0;
        } else if (sc === bc && Math.abs(sr-br) === 2) {
          const mid = indexOf((sr+br)/2, sc);
          board[blank] = board[mid];
          board[mid] = board[cand];
          board[cand] = 0;
        } else {
          // fallback swap
          [board[cand], board[blank]] = [board[blank], board[cand]];
        }
      }
      lastMove = cand;
    }
    // If by chance the shuffle returned the solved state, do one extra random move
    if (isSolvedBoard(board)) {
      // do one legal move
      const blank = idxOf(0);
      const pick = getLegalSources(blank)[0];
      [board[pick], board[blank]] = [board[blank], board[pick]];
    }

    moves = 0;
    resetTimer();
    solved = false;
    updateHUD();
    updateTime();
    render();
    isShuffling = false;
    statusEl.textContent = 'Not solved';
  }

  // Return indices of tiles that can legally move into blank (adjacent or two-away in same row/col)
  function getLegalSources(blankIdx) {
    const br = rowOf(blankIdx), bc = colOf(blankIdx);
    const candidates = [];
    // same row: left/right by 1 or 2
    for (let dc = -2; dc <= 2; dc++) {
      if (dc === 0) continue;
      const c = bc + dc;
      if (c >= 0 && c <= 2) {
        const idx = indexOf(br, c);
        if (canMoveFrom(idx, blankIdx)) candidates.push(idx);
      }
    }
    // same column: up/down by 1 or 2
    for (let dr = -2; dr <= 2; dr++) {
      if (dr === 0) continue;
      const r = br + dr;
      if (r >= 0 && r <= 2) {
        const idx = indexOf(r, bc);
        if (canMoveFrom(idx, blankIdx)) candidates.push(idx);
      }
    }
    // deduplicate
    return [...new Set(candidates)];
  }

  function isSolvedBoard(b) {
    for (let i=0;i<8;i++) if (b[i] !== i+1) return false;
    return b[8] === 0;
  }

  function checkSolved() {
    if (isSolvedBoard(board)) {
      solved = true;
      stopTimer();
      statusEl.textContent = 'Solved!';
      flashBoard();
      recordHighScore();
    } else {
      statusEl.textContent = 'Not solved';
    }
  }

  function flashBoard() {
    // Add flash class briefly
    boardEl.classList.add('flash');
    setTimeout(() => boardEl.classList.remove('flash'), 2000);
  }

  // High scores: save {moves, timeSeconds, when}
  function loadHighScores() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return [];
      return JSON.parse(raw);
    } catch (e) { return []; }
  }
  function saveHighScores(list) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(list.slice(0,5)));
  }

  function recordHighScore() {
    const list = loadHighScores();
    list.push({ moves: moves, time: elapsedSeconds, when: Date.now() });
    // sort: primary by moves ascending, secondary by time ascending
    list.sort((a,b) => a.moves - b.moves || a.time - b.time || a.when - b.when);
    const top = list.slice(0,5);
    saveHighScores(top);
    renderScores();
  }

  function clearScores() {
    localStorage.removeItem(STORAGE_KEY);
    renderScores();
  }

  function renderScores() {
    const list = loadHighScores();
    scoreListEl.innerHTML = '';
    if (list.length === 0) {
      const li = document.createElement('li');
      li.textContent = 'No scores yet';
      scoreListEl.appendChild(li);
      return;
    }
    list.forEach(entry => {
      const li = document.createElement('li');
      const mins = Math.floor(entry.time/60);
      const secs = entry.time % 60;
      li.textContent = `${entry.moves} moves — ${mins}:${secs < 10 ? '0'+secs : secs}`;
      scoreListEl.appendChild(li);
    });
  }

  // Reset to solved state
  function reset() {
    board = solvedLayout().slice();
    moves = 0;
    resetTimer();
    updateHUD();
    updateTime();
    solved = true; // it's solved
    render();
    statusEl.textContent = 'Solved';
  }

  // Initialize
  function init() {
    board = solvedLayout().slice();
    solved = true;
    render();
    updateHUD();
    updateTime();
    renderScores();
    // Event listeners
    shuffleBtn.addEventListener('click', () => {
      shuffle(200);
      // focus board for keyboard control
      boardEl.focus();
    });
    resetBtn.addEventListener('click', () => {
      reset();
      boardEl.focus();
    });
    clearScoresBtn.addEventListener('click', () => {
      if (confirm('Clear all saved high scores?')) {
        clearScores();
      }
    });
    document.addEventListener('keydown', onKeyDown);
    // allow clicking on board background to focus for keyboard support
    boardEl.addEventListener('click', () => boardEl.focus());
  }

  init();

})();
</script>

</body>
</html>
